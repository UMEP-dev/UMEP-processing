# -*- coding: utf-8 -*-

"""
/***************************************************************************
 ProcessingUMEP
                                 A QGIS plugin
 UMEP for processing toolbox
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-04-02
        copyright            : (C) 2020 by Fredrik Lindberg
        email                : fredrikl@gvc.gu.se
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Fredrik Lindberg'
__date__ = '2020-04-02'
__copyright__ = '(C) 2020 by Fredrik Lindberg'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import numpy as np
from typing import Dict, Any
import logging
from osgeo import gdal, osr, ogr
from osgeo.gdalconst import *
import osgeo
import errno
import os

from util.misc import get_ders, saveraster
import zipfile

from util.SEBESOLWEIGCommonFiles.Solweig_v2015_metdata_noload import Solweig_2015a_metdata_noload
from util.SEBESOLWEIGCommonFiles import Solweig_v2015_metdata_noload as metload
from util.SEBESOLWEIGCommonFiles.clearnessindex_2013b import clearnessindex_2013b
from functions.SOLWEIGpython.Tgmaps_v1 import Tgmaps_v1
from functions.SOLWEIGpython import Solweig_2022a_calc_forprocessing as so
from functions.SOLWEIGpython import WriteMetadataSOLWEIG
from functions.SOLWEIGpython import PET_calculations as p
from functions.SOLWEIGpython import UTCI_calculations as utci
import matplotlib.pyplot as plt
import matplotlib
matplotlib.use('agg')
from functions.SOLWEIGpython.CirclePlotBar import PolarBarPlot
from shutil import copyfile, rmtree
import string
import random

# For "Save necessary rasters for TreePlanter tool"
from shutil import copyfile

logger = logging.getLogger(__name__)
FORMAT = "[%(filename)s:%(lineno)s - %(funcName)20s() ] %(message)s"
# logging.basicConfig(format=FORMAT)
logger.setLevel(logging.INFO)
logger.propagate = False


class ProcessingSOLWEIGAlgorithm():
    """
    This algorithm is a processing version of SOLWEIG
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.
    
    #Spatial data
    INPUT_DSM = 'INPUT_DSM'
    INPUT_SVF = 'INPUT_SVF'
    INPUT_CDSM = 'INPUT_CDSM'
    INPUT_TDSM = 'INPUT_TDSM'
    INPUT_HEIGHT = 'INPUT_HEIGHT'
    INPUT_ASPECT = 'INPUT_ASPECT'
    TRANS_VEG = 'TRANS_VEG'
    LEAF_START = 'LEAF_START'
    LEAF_END = 'LEAF_END'
    CONIFER_TREES = 'CONIFER_TREES'
    INPUT_THEIGHT = 'INPUT_THEIGHT'
    INPUT_LC = 'INPUT_LC'
    USE_LC_BUILD = 'USE_LC_BUILD'
    INPUT_DEM = 'INPUT_DEM'
    SAVE_BUILD = 'SAVE_BUILD'
    INPUT_ANISO = 'INPUT_ANISO'

    #Enivornmental parameters
    ALBEDO_WALLS = 'ALBEDO_WALLS'
    ALBEDO_GROUND = 'ALBEDO_GROUND'
    EMIS_WALLS = 'EMIS_WALLS'
    EMIS_GROUND = 'EMIS_GROUND'

    #Tmrt parameters
    ABS_S = 'ABS_S'
    ABS_L = 'ABS_L'
    POSTURE = 'POSTURE'

    #Meteorology
    INPUT_MET = 'INPUTMET'
    ONLYGLOBAL = 'ONLYGLOBAL'
    UTC = 'UTC'

    #PET parameters
    AGE = 'AGE'
    ACTIVITY = 'ACTIVITY'
    CLO = 'CLO'
    WEIGHT = 'WEIGHT'
    HEIGHT = 'HEIGHT'
    SEX = 'SEX'
    SENSOR_HEIGHT = 'SENSOR_HEIGHT'

    #Optional settings
    # POI = 'POI'
    POI_FILE = 'POI_FILE'
    POI_FIELD = 'POI_FIELD'
    CYL = 'CYL'

    #Output
    OUTPUT_DIR = 'OUTPUT_DIR'
    OUTPUT_TMRT = 'OUTPUT_TMRT'
    OUTPUT_LUP = 'OUTPUT_LUP'
    OUTPUT_KUP = 'OUTPUT_KUP'
    OUTPUT_KDOWN = 'OUTPUT_KDOWN'
    OUTPUT_LDOWN = 'OUTPUT_LDOWN'
    OUTPUT_SH = 'OUTPUT_SH'
    OUTPUT_TREEPLANTER = 'OUTPUT_TREEPLANTER'

    def initAlgorithm(self):
        logger.debug("Init SOLWEIG Algorithm")
        self.param_desc_dict = {
            #spatial
            self.INPUT_DSM: {'desc': 'Building and ground Digital Surface Model (DSM)', 'type': str},
            self.INPUT_SVF: {'desc': 'Sky View Factor grids (.zip)', 'extension': 'zip', 'type': str},
            self.INPUT_HEIGHT: {'desc':'Wall height raster', 'type': str},
            self.INPUT_ASPECT: {'desc': 'Wall aspect raster', 'type':str},
            self.INPUT_CDSM: {'desc': 'Vegetation Canopy DSM', 'type': str, 'default': None},
            self.TRANS_VEG: {'desc': 'Transmissivity of light through vegetation (%):', 'type': int, 'min':0, 'max':100, 'default': 3},
            self.LEAF_START: {'desc':'First day of year with leaves on trees (if deciduous)', 'type': int, 'min': 0, 'max': 366, 'default': 97},
            self.LEAF_END: {'desc':'Last day of year with leaves on trees (if deciduous)', 'type':int, 'min':0, 'max': 366, 'default':300},
            self.CONIFER_TREES: {'desc': "Coniferous trees (deciduous default)", 'type':bool, 'default': False},
            self.INPUT_TDSM: {'desc': 'Vegetation Trunk-zone DSM', 'type': str, 'default': None},
            self.INPUT_THEIGHT: {'desc': "Trunk zone height (percent of Canopy Height). Used if no Vegetation Trunk-zone DSM is loaded", 'type': float, 'min': 0.1, 'max': 99.9, 'default': 25.0},
            self.INPUT_LC: {'desc': 'UMEP land cover grid', 'type': str, 'default': None},
            self.USE_LC_BUILD: {'desc': "Use land cover grid to derive building grid", 'type': bool, 'default': False},
            self.INPUT_DEM: {'desc': 'Digital Elevation Model (DEM)', 'type': str, 'default': None},
            self.SAVE_BUILD: {'desc':"Save generated building grid", 'type':bool, 'default': False},
            self.INPUT_ANISO: {'desc': 'Shadow maps used for anisotropic model for sky diffuse and longwave radiation (.npz)','type':str, 'extension': "npz", 'default': None},

            #Environmental parameters
            self.ALBEDO_WALLS: {'desc': 'Albedo (walls)', 'type': float, 'min': 0, 'max': 1, 'default': 0.20},
            self.ALBEDO_GROUND: {'desc': 'Albedo (ground)', 'type': float, 'min': 0, 'max': 1, 'default': 0.15},
            self.EMIS_WALLS: {'desc': 'Emissivity (walls)', 'type': float, 'min': 0, 'max': 1, 'default': 0.9},
            self.EMIS_GROUND: {'desc': 'Emissivity (ground)', 'type': float, 'min': 0, 'max': 1, 'default': 0.95},

            #Tmrt parameters
            self.ABS_S: {'desc': 'Absorption of shortwave radiation of human body', 'type': float, 'min': 0,'max': 1, 'default': 0.70},
            self.ABS_L: {'desc': 'Absorption of longwave radiation of human body', 'type': float, 'min': 0,'max': 1, 'default': 0.95},
            self.POSTURE: {'desc': 'Posture of human body', 'type': int, 'min': 0,'max': 1, 'default':0, 'options': {'0': 'Standing', '1': 'Sitting'}},
            self.CYL: {'desc': "Consider human as cylinder instead of box", 'type': bool, 'default': True},

            #Meteorology
            self.INPUT_MET: {'desc': 'Input meteorological file (.txt)', 'type': str, 'extension': 'txt'},
            self.ONLYGLOBAL: {'desc': "Estimate diffuse and direct shortwave radiation from global radiation", 'type': bool, 'default': False},
            self.UTC: {'desc': 'Coordinated Universal Time (UTC) ', 'type': int, 'min': -12, 'max': 12, 'default': 0},

            #ADVANCED PARAMETERS
            #POIs for thermal comfort estimations
            self.POI_FILE: {'desc': 'Vector point file including Point of Interest(s) for thermal comfort calculations (PET and UTCI)', 'type':str, 'default': None},
            # todo: flags? # poifile.setFlags(poifile.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
            self.POI_FIELD: {'desc': 'ID field', 'type': str, 'default': None},
            # todo: flags? # poi_field.setFlags(poi_field.flags() | QgsProcessingParameterDefinition.FlagAdvanced)

            #PET parameters
            self.AGE: {'desc': 'Age (yy)', 'type': int, 'min': 0, 'max': 120, 'default': 35},
            # todo: flags? # age.setFlags(age.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
            self.ACTIVITY: {'desc': 'Activity (W)', 'type': float, 'min': 0, 'max': 1000, 'default': 80},
            # todo: flags? # act.setFlags(act.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
            self.CLO: {'desc': 'Clothing (clo)', 'type': float, 'min': 0, 'max': 10, 'default': 0.9},
            # tdod: flags? # clo.setFlags(clo.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
            self.WEIGHT: {'desc': 'Weight (kg)', 'type': int, 'min': 0, 'max': 500, 'default': 75},
            # todo: flags? # wei.setFlags(wei.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
            self.HEIGHT: {'desc': 'Height (cm)', 'type': int, 'min': 0, 'max': 250, 'default': 180},
            #todo: flags? # hei.setFlags(hei.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
            self.SEX: {'desc': 'Sex', 'type': int, 'default': 0, 'options': {0: 'Male', 1: 'Female'}},
            # todo: flags? sex.setFlags(sex.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
            self.SENSOR_HEIGHT: {'desc': 'Height of wind sensor (m agl)', 'type': float, 'min': 0, 'max': 250, 'default': 10},
            # todo: flags? # shei.setFlags(shei.flags() | QgsProcessingParameterDefinition.FlagAdvanced)

            #OUTPUT
            self.OUTPUT_TMRT: {'desc': "Save Mean Radiant Temperature raster(s)", 'type': bool, 'default': True},
            self.OUTPUT_KDOWN: {'desc': "Save Incoming shortwave radiation raster(s)", 'type': bool, 'default': False},
            self.OUTPUT_KUP: {'desc': "Save Outgoing shortwave radiation raster(s)", 'type': bool, 'default': False},
            self.OUTPUT_LDOWN: {'desc': "Save Incoming longwave radiation raster(s)", 'type': bool, 'default': False},
            self.OUTPUT_LUP: {'desc': "Save Outgoing longwave radiation raster(s)", 'type': bool, 'default': False},
            self.OUTPUT_SH: {'desc': "Save shadow raster(s)", 'type': bool, 'default': False},
            self.OUTPUT_TREEPLANTER: {'desc': "Save necessary raster(s) for the TreePlanter and Spatial TC tools", 'type': bool, 'default': False},
            self.OUTPUT_DIR: {'desc':'Output folder' , 'type': str},

        }

        self.plugin_dir = os.path.dirname(__file__)
        temp_dir_name = 'temp-' + ''.join(random.choice(string.ascii_uppercase) for _ in range(8))
        self.temp_dir = os.path.join(os.path.dirname(self.plugin_dir), temp_dir_name)

    def processAlgorithm(self, parameters):  # , context, feedback):
        """
        qgis-free vesion of solweig_algorithm.processAlgorithm for executing solweig application

        Args:
            parameters:  dict of parameters for solweig

        Returns:

        """
        logger.debug("Process SOLWEIG Algorithm")
        np.seterr(divide='ignore', invalid='ignore')

        parameter_dict = self.set_solweig_parameter(parameters)

        demforbuild = 0
        poisxy = None
        poiname = None

        # Code from old plugin
        # provider = parameter_dict["dsmlayer"].dataProvider()

        filepath_dsm = parameter_dict["dsmlayer"]  # str(provider.dataSourceUri())
        gdal_dsm = gdal.Open(filepath_dsm, gdal.GA_ReadOnly)
        logger.debug(f"dsm layer: {gdal_dsm} {gdal_dsm.GetRasterBand(1)}")
        dsm = gdal_dsm.ReadAsArray().astype(float)
        sizex = dsm.shape[0]
        sizey = dsm.shape[1]
        rows = dsm.shape[0]
        cols = dsm.shape[1]

        # response to issue #85
        nd = gdal_dsm.GetRasterBand(1).GetNoDataValue()
        dsm[dsm == nd] = 0.
        # dsmcopy = np.copy(dsm)
        if dsm.min() < 0:
            dsmraise = np.abs(dsm.min())
            dsm = dsm + dsmraise
            logger.debug(f"'Digital Surface Model (DSM) included negative values. DSM raised with {str(dsmraise)} m.'")
        else:
            dsmraise = 0

        # Get latlon from grid coordinate system
        # old_cs = osr.SpatialReference()
        # dsm_ref = parameter_dict["dsmlayer"].crs().toWkt()
        # old_cs.ImportFromWkt(dsm_ref)
        old_cs = osr.SpatialReference(wkt=gdal_dsm.GetProjection())  # ().ImportFromWkt
        logger.debug(f"gdal spatial reference {old_cs}")
        logger.debug(f"old name {old_cs.GetAttrValue('AUTHORITY', 0)}")
        logger.debug(f"old id {old_cs.GetAttrValue('AUTHORITY', 1)}")

        wgs84_wkt = """
        GEOGCS["WGS 84",
            DATUM["WGS_1984",
                SPHEROID["WGS 84",6378137,298.257223563,
                    AUTHORITY["EPSG","7030"]],
                AUTHORITY["EPSG","6326"]],
            PRIMEM["Greenwich",0,
                AUTHORITY["EPSG","8901"]],
            UNIT["degree",0.01745329251994328,
                AUTHORITY["EPSG","9122"]],
            AUTHORITY["EPSG","4326"]]"""

        new_cs = osr.SpatialReference()
        new_cs.ImportFromWkt(wgs84_wkt)

         # version stable solution from here: https://github.com/OSGeo/gdal/issues/1546#issuecomment-616344351
        if int(osgeo.__version__[0]) >= 3:
            # GDAL 3 changes axis order: https://github.com/OSGeo/gdal/issues/1546
            old_cs.SetAxisMappingStrategy(osgeo.osr.OAMS_TRADITIONAL_GIS_ORDER)

        transform = osr.CoordinateTransformation(old_cs, new_cs)
        widthx = gdal_dsm.RasterXSize
        heightx = gdal_dsm.RasterYSize
        geotransform = gdal_dsm.GetGeoTransform()
        minx = geotransform[0]
        miny = geotransform[3] + widthx * geotransform[4] + heightx * geotransform[5]

        gdalver = float(gdal.__version__[0])
        lonlat = transform.TransformPoint(minx, miny)
        lon = lonlat[1]  # changed to fit version independent gdal
        lat = lonlat[0]  # changed to fit version independent gdal
        scale = 1 / geotransform[1]

        alt = np.median(dsm)
        if alt < 0:
            alt = 3
        logger.warn(f'Longitude derived from DSM: {str(lon)}')
        logger.warn(f'Latitude derived from DSM: {str(lat)}')
        logger.warn(f"GDAL Version: {gdalver}")

        trunkfile = 0
        trunkratio = 0
        # psi = transVeg / 100.0

        # if useVegdem:
        if parameter_dict["vegdsm"] != "None":
            usevegdem = 1
            logger.debug('Vegetation scheme activated')

            # load raster
            gdal.AllRegister()
            # provider = parameter_dict["vegdsm"].dataProvider()
            filePathOld = parameter_dict["vegdsm"]  # str(provider.dataSourceUri())
            dataSet = gdal.Open(filePathOld)
            vegdsm = dataSet.ReadAsArray().astype(float)
            filePath_cdsm = filePathOld
            vegsizex = vegdsm.shape[0]
            vegsizey = vegdsm.shape[1]

            if not (vegsizex == sizex) & (vegsizey == sizey):
                raise ValueError("Error in Vegetation Canopy DSM: All rasters must be of same extent and resolution")

            if parameter_dict["vegdsm2"] != "None":
                gdal.AllRegister()
                # provider = parameter_dict["vegdsm2"].dataProvider()
                # filePathOld = str(provider.dataSourceUri())
                filePath_tdsm = parameter_dict["vegdsm2"]  # filePathOld
                dataSet = gdal.Open(parameter_dict["vegdsm2"])  # filePathOld)
                vegdsm2 = dataSet.ReadAsArray().astype(float)
            else:
                trunkratio = parameter_dict["trunkr"] / 100.0
                vegdsm2 = vegdsm * trunkratio
                filePath_tdsm = None

            vegsizex = vegdsm2.shape[0]
            vegsizey = vegdsm2.shape[1]

            if not (vegsizex == sizex) & (vegsizey == sizey):  # &
                raise ValueError("Error in Trunk Zone DSM: All rasters must be of same extent and resolution")
        else:
            vegdsm = np.zeros([rows, cols])
            vegdsm2 = np.zeros([rows, cols])
            usevegdem = 0
            filePath_cdsm = None
            filePath_tdsm = None

        # Land cover
        if parameter_dict["lcgrid"] != "None":
            landcover = 1
            logger.debug('Land cover scheme activated')

            # load raster
            gdal.AllRegister()
            # provider = parameter_dict["lcgrid"].dataProvider()
            filePath_lc = parameter_dict["lcgrid"]  # str(provider.dataSourceUri())
            dataSet = gdal.Open(filePath_lc)
            lcgrid = dataSet.ReadAsArray().astype(float)

            lcsizex = lcgrid.shape[0]
            lcsizey = lcgrid.shape[1]

            if not (lcsizex == sizex) & (lcsizey == sizey):
                raise ValueError("Error in land cover grid: All grids must be of same extent and resolution")

            baddataConifer = (lcgrid == 3)
            baddataDecid = (lcgrid == 4)
            if baddataConifer.any():
                raise ValueError("Error in land cover grid: Land cover grid includes Confier land cover class. Ground cover information (underneath canopy) is required.")
            if baddataDecid.any():
                raise ValueError("Error in land cover grid: Land cover grid includes Decidiuous land cover class. Ground cover information (underneath canopy) is required.")
            if np.isnan(lcgrid).any():
                raise ValueError("Error in land cover grid: Land cover grid includes NaN values. Use the QGIS Fill NoData cells tool to remove NaN values.")
        else:
            lcgrid = None  # set manually, otherwise lcgrid would be undefined for later use
            filePath_lc = None
            landcover = 0

        # DEM #
        dem = None  # set manually, otherwise lcgrid would be undefined for later use
        if not parameter_dict["useLcBuild"]:
            demforbuild = 1
            dem = parameter_dict["dem"]

            if dem == "None":
                raise ValueError("Error: No valid DEM selected")

            # load raster
            gdal.AllRegister()
            # provider = dem.dataProvider()
            filePathOld = dem  # str(provider.dataSourceUri())
            dataSet = gdal.Open(filePathOld)
            dem = dataSet.ReadAsArray().astype(float)

            demsizex = dem.shape[0]
            demsizey = dem.shape[1]

            if not (demsizex == sizex) & (demsizey == sizey):
                raise ValueError("Error in DEM: All grids must be of same extent and resolution")

            # response to issue and #230
            nd = dataSet.GetRasterBand(1).GetNoDataValue()
            dem[dem == nd] = 0.
            if dem.min() < 0:
                demraise = np.abs(dem.min())
                dem = dem + demraise
                logger.debug(f'Digital Evevation Model (DEM) included negative values. DEM raised with {str(demraise)} m.')
            else:
                demraise = 0

            alt = np.median(dem)
            if alt > 0:
                alt = 3.

            if (dsmraise != demraise) and (dsmraise - demraise > 0.5):
                logger.warning('WARNiNG! DEM and DSM was raised unequally (difference > 0.5 m). Check your input data!')

        #SVFs
        zip = zipfile.ZipFile(parameter_dict["inputSVF"], 'r')
        zip.extractall(self.temp_dir)
        zip.close()

        try:
            dataSet = gdal.Open(self.temp_dir + "/svf.tif")
            svf = dataSet.ReadAsArray().astype(float)
            dataSet = gdal.Open(self.temp_dir + "/svfN.tif")
            svfN = dataSet.ReadAsArray().astype(float)
            dataSet = gdal.Open(self.temp_dir + "/svfS.tif")
            svfS = dataSet.ReadAsArray().astype(float)
            dataSet = gdal.Open(self.temp_dir + "/svfE.tif")
            svfE = dataSet.ReadAsArray().astype(float)
            dataSet = gdal.Open(self.temp_dir + "/svfW.tif")
            svfW = dataSet.ReadAsArray().astype(float)

            if usevegdem == 1:
                dataSet = gdal.Open(self.temp_dir + "/svfveg.tif")
                svfveg = dataSet.ReadAsArray().astype(float)
                dataSet = gdal.Open(self.temp_dir + "/svfNveg.tif")
                svfNveg = dataSet.ReadAsArray().astype(float)
                dataSet = gdal.Open(self.temp_dir + "/svfSveg.tif")
                svfSveg = dataSet.ReadAsArray().astype(float)
                dataSet = gdal.Open(self.temp_dir + "/svfEveg.tif")
                svfEveg = dataSet.ReadAsArray().astype(float)
                dataSet = gdal.Open(self.temp_dir + "/svfWveg.tif")
                svfWveg = dataSet.ReadAsArray().astype(float)

                dataSet = gdal.Open(self.temp_dir + "/svfaveg.tif")
                svfaveg = dataSet.ReadAsArray().astype(float)
                dataSet = gdal.Open(self.temp_dir + "/svfNaveg.tif")
                svfNaveg = dataSet.ReadAsArray().astype(float)
                dataSet = gdal.Open(self.temp_dir + "/svfSaveg.tif")
                svfSaveg = dataSet.ReadAsArray().astype(float)
                dataSet = gdal.Open(self.temp_dir + "/svfEaveg.tif")
                svfEaveg = dataSet.ReadAsArray().astype(float)
                dataSet = gdal.Open(self.temp_dir + "/svfWaveg.tif")
                svfWaveg = dataSet.ReadAsArray().astype(float)
            else:
                svfveg = np.ones((rows, cols))
                svfNveg = np.ones((rows, cols))
                svfSveg = np.ones((rows, cols))
                svfEveg = np.ones((rows, cols))
                svfWveg = np.ones((rows, cols))
                svfaveg = np.ones((rows, cols))
                svfNaveg = np.ones((rows, cols))
                svfSaveg = np.ones((rows, cols))
                svfEaveg = np.ones((rows, cols))
                svfWaveg = np.ones((rows, cols))
        except:
            raise ValueError("SVF import error: The zipfile including the SVFs seems corrupt. Retry calcualting the SVFs in the Pre-processor or choose another file.")

        svfsizex = svf.shape[0]
        svfsizey = svf.shape[1]

        if not (svfsizex == sizex) & (svfsizey == sizey):  # &
            raise ValueError("Error in svf rasters: All grids must be of same extent and resolution")

        tmp = svf + svfveg - 1.
        tmp[tmp < 0.] = 0.
        # %matlab crazyness around 0
        svfalfa = np.arcsin(np.exp((np.log((1. - tmp)) / 2.)))

        logger.debug('Sky View Factor rasters loaded')

        # wall height layer
        if parameter_dict["whlayer"] == "None":
            raise ValueError("Error: No valid wall height raster layer is selected")
        # provider = parameter_dict["whlayer"].dataProvider()
        filepath_wh = parameter_dict["whlayer"]  # str(provider.dataSourceUri())
        self.gdal_wh = gdal.Open(filepath_wh)
        wallheight = self.gdal_wh.ReadAsArray().astype(float)
        vhsizex = wallheight.shape[0]
        vhsizey = wallheight.shape[1]
        if not (vhsizex == sizex) & (vhsizey == sizey):
            raise ValueError("Error in Wall height raster: All rasters must be of same extent and resolution")
            # raise QgsProcessingException("Error in Wall height raster: All rasters must be of same extent and resolution")

        # wall aspect layer
        if parameter_dict["walayer"] == "None":
            raise ValueError("Error: No valid wall aspect raster layer is selected")
        # provider = parameter_dict["walayer"].dataProvider()
        filepath_wa = parameter_dict["walayer"] # str(provider.dataSourceUri())
        self.gdal_wa = gdal.Open(filepath_wa)
        wallaspect = self.gdal_wa.ReadAsArray().astype(float)
        vasizex = wallaspect.shape[0]
        vasizey = wallaspect.shape[1]
        if not (vasizex == sizex) & (vasizey == sizey):
            raise ValueError("Error in Wall aspect raster: All rasters must be of same extent and resolution")

        voxelheight = geotransform[1]  # float

        # Metdata
        headernum = 1
        delim = ' '
        Twater = []

        try:
            self.metdata = np.loadtxt(parameter_dict["inputMet"],skiprows=headernum, delimiter=delim)
            logger.debug(f"metfile {self.metdata}")
            metfileexist = 1
        except Exception as e:
            raise ValueError("Error: Make sure format of meteorological file is correct. You can"
                             "prepare your data by using 'Prepare Existing Data' in "
                             f"the Pre-processor {e}")

        testwhere = np.where((self.metdata[:, 14] < 0.0) | (self.metdata[:, 14] > 1300.0))
        if testwhere[0].__len__() > 0:
            raise ValueError(f"Error: Kdown - beyond what is expected at line: {str(testwhere[0] + 1)}")

        if self.metdata.shape[1] == 24:
            logger.debug("Meteorological data successfully loaded")
        else:
            raise ValueError("Error: Wrong number of columns in meteorological data. You can "
                             "prepare your data by using 'Prepare Existing Data' in "
                             "the Pre-processor")

        location = {'longitude': lon, 'latitude': lat, 'altitude': alt}
        logger.debug(f"Calculating sun positions for each time step {location}")
        YYYY, altitude, azimuth, zen, jday, leafon, dectime, altmax = \
            Solweig_2015a_metdata_noload(self.metdata, location, parameter_dict["utc"])

        # Creating vectors from meteorological input
        DOY = self.metdata[:, 1]
        hours = self.metdata[:, 2]
        minu = self.metdata[:, 3]
        Ta = self.metdata[:, 11]
        RH = self.metdata[:, 10]
        radG = self.metdata[:, 14]
        radD = self.metdata[:, 21]
        radI = self.metdata[:, 22]
        P = self.metdata[:, 12]
        Ws = self.metdata[:, 9]
        logger.debug(f"metadata first row: {self.metdata[0, :]}")
        
        # Check if diffuse and direct radiation exist
        if parameter_dict["onlyglobal"] == 0:
            if np.min(radD) == -999:
                raise ValueError("Diffuse radiation include NoData values",
                                 'Tick in the box "Estimate diffuse and direct shortwave..." or aqcuire '
                                 'observed values from external data sources.')
            if np.min(radI) == -999:
                raise ValueError("Direct radiation include NoData values",
                                 'Tick in the box "Estimate diffuse and direct shortwave..." or aqcuire '
                                 'observed values from external data sources.')

        # POIs check
        if parameter_dict["poilyr"] != "None": # usePOI:
            #header = 'yyyy id   it imin dectime altitude azimuth kdir kdiff kglobal kdown   kup    keast ksouth ' \
            #            'kwest knorth ldown   lup    least lsouth lwest  lnorth   Ta      Tg     RH    Esky   Tmrt    ' \
            #            'I0     CI   Shadow  SVF_b  SVF_bv KsideI PET UTCI'

            header = 'yyyy id it imin dectime altitude azimuth kdir kdiff kglobal kdown kup keast ksouth ' \
                        'kwest knorth ldown lup least lsouth lwest lnorth Ta Tg RH Esky Tmrt ' \
                        'I0 CI Shadow SVF_b SVF_bv KsideI PET UTCI CI_Tg CI_TgG KsideD Lside diffDown Kside'

            # poilyr = self.parameterAsVectorLayer(parameters, self.POI_FILE, context) 
            # if poilyr is None:
                # raise QgsProcessingException("No valid point layer is selected")

            poi_field = parameter_dict["poi_field"]
            # if poi_field[0] is None:
            #     raise QgsProcessingException("An attribute field with unique values must be selected when using a POI vector file")
            vlayer = parameter_dict["poilyr"]
            # handle POI as shapefile instead of QgsVectorLayer
            driver = ogr.GetDriverByName("ESRI Shapefile")
            shape = driver.Open(vlayer, 0)

            vlayer = shape.GetLayer()

            # extract indexFromName poi_field
            fields = driver.Open(parameter_dict['poilyr'], 1)
            layer_defn = fields.GetLayer().GetLayerDefn()
            id_name_tuples = [(i, layer_defn.GetFieldDefn(i).GetName()) for i in range(layer_defn.GetFieldCount())]
            matching_fields = list(filter(lambda t: t[1] == parameter_dict['poi_field'], id_name_tuples))

            try:
                idx = matching_fields[0][0]
            except:
                print(f"Error: POI file ({parameter_dict['poilyr']}) does not have the expected field '{parameter_dict['poi_field']}'. Exiting ..")
                exit(1)

            numfeat = vlayer.GetFeatureCount()
            poiname = []
            poisxy = np.zeros((numfeat, 3)) - 999
            ind = 0

            for feature_index in range(numfeat): # looping through each POI
                f = vlayer.GetFeature(feature_index)
                y = f.geometry().Centroid().GetY()
                x = f.geometry().Centroid().GetX()
                poiname.append(f.GetField(idx))
                poisxy[ind, 0] = ind
                poisxy[ind, 1] = np.round((x - minx) * scale)
                if miny >= 0:
                    poisxy[ind, 2] = np.round((miny + rows * (1. / scale) - y) * scale)
                else:
                    poisxy[ind, 2] = np.round((miny + rows * (1. / scale) - y) * scale)

                ind += 1

            for k in range(0, poisxy.shape[0]):
                logger.debug(f"save poi: {k} {str(poiname[k])} {poisxy[k, :]}")
                poi_save = []  # np.zeros((1, 33))
                data_out = parameter_dict["outputDir"] + '/POI_' + str(poiname[k]) + '.txt'
                np.savetxt(data_out, poi_save,  delimiter=' ', header=header, comments='')
            
            # Other PET variables
            # mbody = parameter_dict["mbody"]  # self.parameterAsDouble(parameters, self.WEIGHT, context)
            # ht = parameter_dict["ht"]  # self.parameterAsDouble(parameters, self.HEIGHT, context) / 100.
            # clo = parameter_dict["clo"]  # self.parameterAsDouble(parameters, self.CLO, context)
            # age = parameter_dict["age"]  # self.parameterAsDouble(parameters, self.AGE, context)
            # activity = parameter_dict["activity"]  # self.parameterAsDouble(parameters, self.WEIGHT, context)
            # sex = parameter_dict["sex"]  # self.parameterAsInt(parameters, self.SEX, context) + 1
            # sensorheight = parameter_dict["sensorheight"]  # self.parameterAsDouble(parameters, self.SENSOR_HEIGHT, context)

            logger.debug("Point of interest (POI) vector data successfully loaded")

        # %Parameterisarion for Lup
        # never True?! - unnecessarry request
        if not parameter_dict["height"]:
            parameter_dict["height"] = 1.1

        # %Radiative surface influence, Rule of thumb by Schmid et al. (1990).
        first = np.round(parameter_dict["height"])
        if first == 0.:
            first = 1.
        second = np.round((parameter_dict["height"] * 20.))

        if usevegdem == 1:
            # Conifer or deciduous
            if parameter_dict["conifer_bool"]:
                leafon = np.ones((1, DOY.shape[0]))
            else:
                leafon = np.zeros((1, DOY.shape[0]))
                if parameter_dict["firstdayleaf"] > parameter_dict["lastdayleaf"]:
                    leaf_bool = ((DOY > parameter_dict["firstdayleaf"]) | (DOY < parameter_dict["lastdayleaf"]))
                else:
                    leaf_bool = ((DOY > parameter_dict["firstdayleaf"]) & (DOY < parameter_dict["lastdayleaf"]))
                leafon[0, leaf_bool] = 1

            # % Vegetation transmittivity of shortwave radiation
            psi = leafon * parameter_dict["transVeg"]
            psi[leafon == 0] = 0.5
            # amaxvalue
            vegmax = vegdsm.max()
            amaxvalue = dsm.max() - dsm.min()
            amaxvalue = np.maximum(amaxvalue, vegmax)

            # Elevation vegdsms if buildingDEM includes ground heights
            vegdsm = vegdsm + dsm
            vegdsm[vegdsm == dsm] = 0
            vegdsm2 = vegdsm2 + dsm
            vegdsm2[vegdsm2 == dsm] = 0

            # % Bush separation
            bush = np.logical_not((vegdsm2 * vegdsm)) * vegdsm

            svfbuveg = (svf - (1. - svfveg) * (1. - parameter_dict["transVeg"]))  # % major bug fixed 20141203
        else:
            psi = leafon * 0. + 1.
            svfbuveg = svf
            bush = np.zeros([rows, cols])
            amaxvalue = 0

        # %Initialization of maps
        Knight = np.zeros((rows, cols))
        Tgmap1 = np.zeros((rows, cols))
        Tgmap1E = np.zeros((rows, cols))
        Tgmap1S = np.zeros((rows, cols))
        Tgmap1W = np.zeros((rows, cols))
        Tgmap1N = np.zeros((rows, cols))
        
        # building grid and land cover preparation
        sitein = self.plugin_dir + "/landcoverclasses_2016a.txt"
        f = open(sitein)
        lin = f.readlines()
        lc_class = np.zeros((lin.__len__() - 1, 6))
        for i in range(1, lin.__len__()):
            lines = lin[i].split()
            for j in np.arange(1, 7):
                lc_class[i - 1, j - 1] = float(lines[j])

        if demforbuild == 0:
            buildings = np.copy(lcgrid)
            buildings[buildings == 7] = 1
            buildings[buildings == 6] = 1
            buildings[buildings == 5] = 1
            buildings[buildings == 4] = 1
            buildings[buildings == 3] = 1
            buildings[buildings == 2] = 0
        else:
            buildings = dsm - dem
            buildings[buildings < 2.] = 1.
            buildings[buildings >= 2.] = 0.

        if parameter_dict["saveBuild"]:
            saveraster(gdal_dsm, parameter_dict["outputDir"] + '/buildings.tif', buildings)

        # Import shadow matrices (Anisotropic sky)
        if parameter_dict["folderPathPerez"] != "None":  #UseAniso
            anisotropic_sky = 1
            data = np.load(parameter_dict["folderPathPerez"])
            shmat = data['shadowmat']
            vegshmat = data['vegshadowmat']
            vbshvegshmat = data['vbshmat']
            if usevegdem == 1:
                diffsh = np.zeros((rows, cols, shmat.shape[2]))
                for i in range(0, shmat.shape[2]):
                    diffsh[:, :, i] = shmat[:, :, i] - (1 - vegshmat[:, :, i]) * (1 - parameter_dict["transVeg"]) # changes in psi not implemented yet
            else:
                diffsh = shmat
                vegshmat += 1
                vbshvegshmat += 1

            # Estimate number of patches based on shadow matrices
            if shmat.shape[2] == 145:
                patch_option = 1 # patch_option = 1 # 145 patches
            elif shmat.shape[2] == 153:
                patch_option = 2 # patch_option = 2 # 153 patches
            elif shmat.shape[2] == 306:
                patch_option = 3 # patch_option = 3 # 306 patches
            elif shmat.shape[2] == 612:
                patch_option = 4 # patch_option = 4 # 612 patches
            else:
                logger.debug(f"patch_option was not set, since number shadow matrices {shmat.shape[2]} was not recognized.")

            # asvf to calculate sunlit and shaded patches
            asvf = np.arccos(np.sqrt(svf))

            anisotropic_feedback = "Sky divided into " + str(int(shmat.shape[2])) + " patches\n \
                                    Anisotropic sky for diffuse shortwave radiation (Perez et al., 1993) and longwave radiation (Martin & Berdahl, 1984)"
            logger.debug(anisotropic_feedback)
        else:
            logger.debug("Isotropic sky")
            anisotropic_sky = 0
            diffsh = None
            shmat = None
            vegshmat = None
            vbshvegshmat = None
            asvf = None
            patch_option = 0

        # % Ts parameterisation maps
        if landcover == 1.:
            if np.max(lcgrid) > 21 or np.min(lcgrid) < 1:
                raise ValueError("The land cover grid includes integer values higher (or lower) than UMEP-formatted"
                                 "land cover grid (should be integer between 1 and 7). If other LC-classes should be included they also need to be included in landcoverclasses_2016a.txt")
            if np.where(lcgrid) == 3 or np.where(lcgrid) == 4:
                raise ValueError("The land cover grid includes values (decidouos and/or conifer) not appropriate for SOLWEIG-formatted land cover grid (should not include 3 or 4).")

            [TgK, Tstart, alb_grid, emis_grid, TgK_wall, Tstart_wall, TmaxLST, TmaxLST_wall] = Tgmaps_v1(lcgrid, lc_class)
        else:
            TgK = Knight + 0.37
            Tstart = Knight - 3.41
            alb_grid = Knight + parameter_dict["albedo_g"]
            emis_grid = Knight + parameter_dict["eground"]
            TgK_wall = 0.37
            Tstart_wall = -3.41
            TmaxLST = 15.
            TmaxLST_wall = 15.

         # Initialisation of time related variables
        if Ta.__len__() == 1:
            timestepdec = 0
        else:
            timestepdec = dectime[1] - dectime[0]
        timeadd = 0.
        timeaddE = 0.
        timeaddS = 0.
        timeaddW = 0.
        timeaddN = 0.
        firstdaytime = 1.

        # todo: write it to a logfile or so
        WriteMetadataSOLWEIG.writeRunInfo(parameter_dict["outputDir"], filepath_dsm, gdal_dsm, usevegdem,
                                          filePath_cdsm, trunkfile, filePath_tdsm, lat, lon, parameter_dict["utc"],
                                          landcover,filePath_lc, metfileexist, parameter_dict["inputMet"], self.metdata,
                                          self.plugin_dir, parameter_dict["absK"], parameter_dict["absL"],
                                          parameter_dict["albedo_b"], parameter_dict["albedo_g"],
                                          parameter_dict["ewall"], parameter_dict["eground"],
                                          parameter_dict["onlyglobal"], trunkratio, parameter_dict["transVeg"],
                                          rows, cols, parameter_dict["pos"], parameter_dict["elvis"],
                                          parameter_dict["cyl"], demforbuild, anisotropic_sky)

        logger.debug("Writing settings for this model run to specified output folder (Filename: RunInfoSOLWEIG_YYYY_DOY_HHMM.txt)")

        # Save svf
        if anisotropic_sky:
            if not poisxy is None:
                patch_characteristics = np.zeros((shmat.shape[2], poisxy.shape[0]))
                for idx in range(poisxy.shape[0]):
                    for idy in range(shmat.shape[2]):
                        # Calculations for patches on sky, shmat = 1 = sky is visible
                        temp_sky = ((shmat[:,:,idy] == 1) & (vegshmat[:,:,idy] == 1))
                        # Calculations for patches that are vegetation, vegshmat = 0 = shade from vegetation
                        temp_vegsh = ((vegshmat[:,:,idy] == 0) | (vbshvegshmat[:,:,idy] == 0))
                        # Calculations for patches that are buildings, shmat = 0 = shade from buildings
                        temp_vbsh = (1 - shmat[:,:,idy]) * vbshvegshmat[:,:,idy]
                        temp_sh = (temp_vbsh == 1)
                        # Sky patch
                        if temp_sky[int(poisxy[idx, 2]), int(poisxy[idx, 1])]:
                            patch_characteristics[idy,idx] = 1.8
                        # Vegetation patch
                        elif (temp_vegsh[int(poisxy[idx, 2]), int(poisxy[idx, 1])]):
                            patch_characteristics[idy,idx] = 2.5
                        # Building patch
                        elif (temp_sh[int(poisxy[idx, 2]), int(poisxy[idx, 1])]):
                            patch_characteristics[idy,idx] = 4.5

        #  If metfile starts at night
        CI = 1.

        # Main function
        logger.debug("Executing main model")
    
        tmrtplot = np.zeros((rows, cols))
        TgOut1 = np.zeros((rows, cols))

        # Initiate array for I0 values
        if np.unique(DOY).shape[0] > 1:
            unique_days = np.unique(DOY)
            first_unique_day = DOY[DOY == unique_days[0]]
            I0_array = np.zeros((first_unique_day.shape[0]))
        else:
            first_unique_day = DOY.copy()
            I0_array = np.zeros((DOY.shape[0]))

        #numformat = '%d %d %d %d %.5f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f ' \
        #            '%.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f'

        numformat = '%d %d %d %d %.5f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f ' \
                    '%.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f ' \
                        '%.2f %.2f %.2f %.2f %.2f %.2f %.2f %.2f'

        for i in np.arange(0, Ta.__len__()):
            logger.debug(f"{int(i * (100. / Ta.__len__()))}")
            # Daily water body temperature
            if landcover == 1:
                if ((dectime[i] - np.floor(dectime[i]))) == 0 or (i == 0):
                    Twater = np.mean(Ta[jday[0] == np.floor(dectime[i])])
            # Nocturnal cloudfraction from Offerle et al. 2003
            if (dectime[i] - np.floor(dectime[i])) == 0:
                daylines = np.where(np.floor(dectime) == dectime[i])
                if daylines.__len__() > 1:
                    alt = altitude[0][daylines]
                    alt2 = np.where(alt > 1)
                    rise = alt2[0][0]
                    [_, CI, _, _, _] = clearnessindex_2013b(zen[0, i + rise + 1], jday[0, i + rise + 1],
                                                            Ta[i + rise + 1],
                                                            RH[i + rise + 1] / 100., radG[i + rise + 1], location,
                                                            P[i + rise + 1])  # i+rise+1 to match matlab code. correct?
                    if (CI > 1.) or (CI == np.inf):
                        CI = 1.
                else:
                    CI = 1.

            # radI[i] = radI[i]/np.sin(altitude[0][i] * np.pi/180)

            Tmrt, Kdown, Kup, Ldown, Lup, Tg, ea, esky, I0, CI, shadow, firstdaytime, timestepdec, timeadd, \
                    Tgmap1, Tgmap1E, Tgmap1S, Tgmap1W, Tgmap1N, Keast, Ksouth, Kwest, Knorth, Least, \
                    Lsouth, Lwest, Lnorth, KsideI, TgOut1, TgOut, radIout, radDout, \
                    Lside, Lsky_patch_characteristics, CI_Tg, CI_TgG, KsideD, \
                        dRad, Kside = so.Solweig_2022a_calc(
                        i, dsm, scale, rows, cols, svf, svfN, svfW, svfE, svfS, svfveg,
                        svfNveg, svfEveg, svfSveg, svfWveg, svfaveg, svfEaveg, svfSaveg, svfWaveg, svfNaveg,
                        vegdsm, vegdsm2, parameter_dict["albedo_b"], parameter_dict["absK"], parameter_dict["absL"],
                        parameter_dict["ewall"], parameter_dict["Fside"], parameter_dict["Fup"], parameter_dict["Fcyl"], altitude[0][i],
                        azimuth[0][i], zen[0][i], jday[0][i], usevegdem, parameter_dict["onlyglobal"], buildings, location,
                        psi[0][i], landcover, lcgrid, dectime[i], altmax[0][i], wallaspect,
                        wallheight, parameter_dict["cyl"], parameter_dict["elvis"], Ta[i], RH[i], radG[i], radD[i], radI[i], P[i], amaxvalue,
                        bush, Twater, TgK, Tstart, alb_grid, emis_grid, TgK_wall, Tstart_wall, TmaxLST,
                        TmaxLST_wall, first, second, svfalfa, svfbuveg, firstdaytime, timeadd, timestepdec, 
                        Tgmap1, Tgmap1E, Tgmap1S, Tgmap1W, Tgmap1N, CI, TgOut1, diffsh, shmat, vegshmat, vbshvegshmat, 
                        anisotropic_sky, asvf, patch_option)

            # Tmrt, Kdown, Kup, Ldown, Lup, Tg, ea, esky, I0, CI, shadow, firstdaytime, timestepdec, timeadd, \
            #         Tgmap1, Tgmap1E, Tgmap1S, Tgmap1W, Tgmap1N, Keast, Ksouth, Kwest, Knorth, Least, \
            #         Lsouth, Lwest, Lnorth, KsideI, TgOut1, TgOut, radIout, radDout = so.Solweig_2021a_calc(
            #             i, dsm, scale, rows, cols, svf, svfN, svfW, svfE, svfS, svfveg,
            #             svfNveg, svfEveg, svfSveg, svfWveg, svfaveg, svfEaveg, svfSaveg, svfWaveg, svfNaveg,
            #             vegdsm, vegdsm2, albedo_b, absK, absL, ewall, Fside, Fup, Fcyl, altitude[0][i],
            #             azimuth[0][i], zen[0][i], jday[0][i], usevegdem, onlyglobal, buildings, location,
            #             psi[0][i], landcover, lcgrid, dectime[i], altmax[0][i], wallaspect,
            #             wallheight, cyl, elvis, Ta[i], RH[i], radG[i], radD[i], radI[i], P[i], amaxvalue,
            #             bush, Twater, TgK, Tstart, alb_grid, emis_grid, TgK_wall, Tstart_wall, TmaxLST,
            #             TmaxLST_wall, first, second, svfalfa, svfbuveg, firstdaytime, timeadd, timestepdec, 
            #             Tgmap1, Tgmap1E, Tgmap1S, Tgmap1W, Tgmap1N, CI, TgOut1, diffsh, ani)



            # Tmrt, Kdown, Kup, Ldown, Lup, Tg, ea, esky, I0, CI, shadow, firstdaytime, timestepdec, timeadd, \
            # Tgmap1, timeaddE, Tgmap1E, timeaddS, Tgmap1S, timeaddW, Tgmap1W, timeaddN, Tgmap1N, \
            # Keast, Ksouth, Kwest, Knorth, Least, Lsouth, Lwest, Lnorth, KsideI, TgOut1, TgOut, radIout, radDout \
            #     = so.Solweig_2019a_calc(i, dsm, scale, rows, cols, svf, svfN, svfW, svfE, svfS, svfveg,
            #         svfNveg, svfEveg, svfSveg, svfWveg, svfaveg, svfEaveg, svfSaveg, svfWaveg, svfNaveg,
            #         vegdsm, vegdsm2, albedo_b, absK, absL, ewall, Fside, Fup, Fcyl, altitude[0][i],
            #         azimuth[0][i], zen[0][i], jday[0][i], usevegdem, onlyglobal, buildings, location,
            #         psi[0][i], landcover, lcgrid, dectime[i], altmax[0][i], waspect,
            #         wheight, cyl, elvis, Ta[i], RH[i], radG[i], radD[i], radI[i], P[i], amaxvalue,
            #         bush, Twater, TgK, Tstart, alb_grid, emis_grid, TgK_wall, Tstart_wall, TmaxLST,
            #         TmaxLST_wall, first, second, svfalfa, svfbuveg, firstdaytime, timeadd, timeaddE, timeaddS,
            #         timeaddW, timeaddN, timestepdec, Tgmap1, Tgmap1E, Tgmap1S, Tgmap1W, Tgmap1N, CI, TgOut1, diffsh, ani)

            # Save I0 for I0 vs. Kdown output plot to check if UTC is off
            if i < first_unique_day.shape[0]:
                I0_array[i] = I0

            tmrtplot = tmrtplot + Tmrt

            if altitude[0][i] > 0:
                w = 'D'
            else:
                w = 'N'

            # # Write to POIs
            # if not poisxy is None:
            #     for k in range(0, poisxy.shape[0]):
            #         poi_save = np.zeros((1, 35))
            #         poi_save[0, 0] = YYYY[0][i]
            #         poi_save[0, 1] = jday[0][i]
            #         poi_save[0, 2] = hours[i]
            #         poi_save[0, 3] = minu[i]
            #         poi_save[0, 4] = dectime[i]
            #         poi_save[0, 5] = altitude[0][i]
            #         poi_save[0, 6] = azimuth[0][i]
            #         poi_save[0, 7] = radIout
            #         poi_save[0, 8] = radDout
            #         poi_save[0, 9] = radG[i]
            #         poi_save[0, 10] = Kdown[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         poi_save[0, 11] = Kup[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         poi_save[0, 12] = Keast[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         poi_save[0, 13] = Ksouth[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         poi_save[0, 14] = Kwest[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         poi_save[0, 15] = Knorth[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         poi_save[0, 16] = Ldown[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         poi_save[0, 17] = Lup[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         poi_save[0, 18] = Least[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         poi_save[0, 19] = Lsouth[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         poi_save[0, 20] = Lwest[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         poi_save[0, 21] = Lnorth[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         poi_save[0, 22] = Ta[i]
            #         poi_save[0, 23] = TgOut[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         poi_save[0, 24] = RH[i]
            #         poi_save[0, 25] = esky
            #         poi_save[0, 26] = Tmrt[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         poi_save[0, 27] = I0
            #         poi_save[0, 28] = CI
            #         poi_save[0, 29] = shadow[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         poi_save[0, 30] = svf[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         poi_save[0, 31] = svfbuveg[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         poi_save[0, 32] = KsideI[int(poisxy[k, 2]), int(poisxy[k, 1])]
            #         # Recalculating wind speed based on powerlaw
            #         WsPET = (1.1 / sensorheight) ** 0.2 * Ws[i]
            #         WsUTCI = (10. / sensorheight) ** 0.2 * Ws[i]
            #         resultPET = p._PET(Ta[i], RH[i], Tmrt[int(poisxy[k, 2]), int(poisxy[k, 1])], WsPET,
            #                             mbody, age, ht, activity, clo, sex)
            #         poi_save[0, 33] = resultPET
            #         resultUTCI = utci.utci_calculator(Ta[i], RH[i], Tmrt[int(poisxy[k, 2]), int(poisxy[k, 1])],
            #                                             WsUTCI)
            #         poi_save[0, 34] = resultUTCI
            #         data_out = outputDir + '/POI_' + str(poiname[k]) + '.txt'
            #         # f_handle = file(data_out, 'a')
            #         f_handle = open(data_out, 'ab')
            #         np.savetxt(f_handle, poi_save, fmt=numformat)
            #         f_handle.close()

            # Write to POIs
            if not poisxy is None:
                for k in range(0, poisxy.shape[0]):
                    poi_save = np.zeros((1, 41))
                    poi_save[0, 0] = YYYY[0][i]
                    poi_save[0, 1] = jday[0][i]
                    poi_save[0, 2] = hours[i]
                    poi_save[0, 3] = minu[i]
                    poi_save[0, 4] = dectime[i]
                    poi_save[0, 5] = altitude[0][i]
                    poi_save[0, 6] = azimuth[0][i]
                    poi_save[0, 7] = radIout
                    poi_save[0, 8] = radDout
                    poi_save[0, 9] = radG[i]
                    poi_save[0, 10] = Kdown[int(poisxy[k, 2]), int(poisxy[k, 1])]
                    poi_save[0, 11] = Kup[int(poisxy[k, 2]), int(poisxy[k, 1])]
                    poi_save[0, 12] = Keast[int(poisxy[k, 2]), int(poisxy[k, 1])]
                    poi_save[0, 13] = Ksouth[int(poisxy[k, 2]), int(poisxy[k, 1])]
                    poi_save[0, 14] = Kwest[int(poisxy[k, 2]), int(poisxy[k, 1])]
                    poi_save[0, 15] = Knorth[int(poisxy[k, 2]), int(poisxy[k, 1])]
                    poi_save[0, 16] = Ldown[int(poisxy[k, 2]), int(poisxy[k, 1])]
                    poi_save[0, 17] = Lup[int(poisxy[k, 2]), int(poisxy[k, 1])]
                    poi_save[0, 18] = Least[int(poisxy[k, 2]), int(poisxy[k, 1])]
                    poi_save[0, 19] = Lsouth[int(poisxy[k, 2]), int(poisxy[k, 1])]
                    poi_save[0, 20] = Lwest[int(poisxy[k, 2]), int(poisxy[k, 1])]
                    poi_save[0, 21] = Lnorth[int(poisxy[k, 2]), int(poisxy[k, 1])]
                    poi_save[0, 22] = Ta[i]
                    poi_save[0, 23] = TgOut[int(poisxy[k, 2]), int(poisxy[k, 1])]
                    poi_save[0, 24] = RH[i]
                    poi_save[0, 25] = esky
                    poi_save[0, 26] = Tmrt[int(poisxy[k, 2]), int(poisxy[k, 1])]
                    poi_save[0, 27] = I0
                    poi_save[0, 28] = CI
                    poi_save[0, 29] = shadow[int(poisxy[k, 2]), int(poisxy[k, 1])]
                    poi_save[0, 30] = svf[int(poisxy[k, 2]), int(poisxy[k, 1])]
                    poi_save[0, 31] = svfbuveg[int(poisxy[k, 2]), int(poisxy[k, 1])]
                    poi_save[0, 32] = KsideI[int(poisxy[k, 2]), int(poisxy[k, 1])]
                    # Recalculating wind speed based on powerlaw
                    WsPET = (1.1 / parameter_dict["sensorheight"]) ** 0.2 * Ws[i]
                    WsUTCI = (10. / parameter_dict["sensorheight"]) ** 0.2 * Ws[i]
                    resultPET = p._PET(Ta[i], RH[i], Tmrt[int(poisxy[k, 2]), int(poisxy[k, 1])], WsPET,
                                        parameter_dict["mbody"], parameter_dict["age"], parameter_dict["ht"],
                                        parameter_dict["activity"], parameter_dict["clo"], parameter_dict["sex"])
                    poi_save[0, 33] = resultPET
                    resultUTCI = utci.utci_calculator(Ta[i], RH[i], Tmrt[int(poisxy[k, 2]), int(poisxy[k, 1])],
                                                        WsUTCI)
                    poi_save[0, 34] = resultUTCI
                    poi_save[0, 35] = CI_Tg
                    poi_save[0, 36] = CI_TgG
                    poi_save[0, 37] = KsideD[int(poisxy[k, 2]), int(poisxy[k, 1])]
                    poi_save[0, 38] = Lside[int(poisxy[k, 2]), int(poisxy[k, 1])]
                    poi_save[0, 39] = dRad[int(poisxy[k, 2]), int(poisxy[k, 1])]
                    poi_save[0, 40] = Kside[int(poisxy[k, 2]), int(poisxy[k, 1])]
                    data_out = parameter_dict["outputDir"] + '/POI_' + str(poiname[k]) + '.txt'
                    # f_handle = file(data_out, 'a')
                    f_handle = open(data_out, 'ab')
                    np.savetxt(f_handle, poi_save, fmt=numformat)
                    f_handle.close()

            if hours[i] < 10:
                XH = '0'
            else:
                XH = ''
            if minu[i] < 10:
                XM = '0'
            else:
                XM = ''
            logger.debug(f"write files {parameter_dict['outputTmrt']} {parameter_dict['outputDir'] + '/Tmrt_' + str(int(YYYY[0, i])) + '_' + str(int(DOY[i])) + '_' + XH + str(int(hours[i])) + XM + str(int(minu[i])) + w + '.tif'}")
            logger.debug(f"output sh {parameter_dict['outputSh']} {parameter_dict['outputDir'] + '/Shadow_' + str(int(YYYY[0, i])) + '_' + str(int(DOY[i])) + '_' + XH + str(int(hours[i])) + XM + str(int(minu[i])) + w + '.tif'}")
            if parameter_dict["outputTmrt"]:

                saveraster(gdal_dsm, parameter_dict["outputDir"] + '/Tmrt_' + str(int(YYYY[0, i])) + '_' + str(int(DOY[i]))
                                + '_' + XH + str(int(hours[i])) + XM + str(int(minu[i])) + w + '.tif', Tmrt)
            if parameter_dict["outputKup"]:
                saveraster(gdal_dsm, parameter_dict["outputDir"] + '/Kup_' + str(int(YYYY[0, i])) + '_' + str(int(DOY[i]))
                                + '_' + XH + str(int(hours[i])) + XM + str(int(minu[i])) + w + '.tif', Kup)
            if parameter_dict["outputKdown"]:
                saveraster(gdal_dsm, parameter_dict["outputDir"] + '/Kdown_' + str(int(YYYY[0, i])) + '_' + str(int(DOY[i]))
                                + '_' + XH + str(int(hours[i])) + XM + str(int(minu[i])) + w + '.tif', Kdown)
            if parameter_dict["outputLup"]:
                saveraster(gdal_dsm, parameter_dict["outputDir"] + '/Lup_' + str(int(YYYY[0, i])) + '_' + str(int(DOY[i]))
                                + '_' + XH + str(int(hours[i])) + XM + str(int(minu[i])) + w + '.tif', Lup)
            if parameter_dict["outputLdown"]:
                saveraster(gdal_dsm, parameter_dict["outputDir"] + '/Ldown_' + str(int(YYYY[0, i])) + '_' + str(int(DOY[i]))
                                + '_' + XH + str(int(hours[i])) + XM + str(int(minu[i])) + w + '.tif', Ldown)
            if parameter_dict["outputSh"]:
                saveraster(gdal_dsm, parameter_dict["outputDir"] + '/Shadow_' + str(int(YYYY[0, i])) + '_' + str(int(DOY[i]))
                                + '_' + XH + str(int(hours[i])) + XM + str(int(minu[i])) + w + '.tif', shadow)

            if parameter_dict["outputKdiff"]:
                saveraster(gdal_dsm, parameter_dict["outputDir"] + '/Kdiff_' + str(int(YYYY[0, i])) + '_' + str(int(DOY[i]))
                                + '_' + XH + str(int(hours[i])) + XM + str(int(minu[i])) + w + '.tif', dRad)

            # if outputSstr:
            #     saveraster(gdal_dsm, outputDir + '/Sstr_' + str(int(YYYY[0, i])) + '_' + str(int(DOY[i]))
            #                     + '_' + XH + str(int(hours[i])) + XM + str(int(minu[i])) + w + '.tif', Sstr)

            # Sky view image of patches
            if ((anisotropic_sky == 1) & (i == 0) & (not poisxy is None)):
                    for k in range(poisxy.shape[0]):
                        Lsky_patch_characteristics[:,2] = patch_characteristics[:,k]
                        skyviewimage_out = parameter_dict["outputDir"] + '/POI_' + str(poiname[k]) + '.png'
                        PolarBarPlot(Lsky_patch_characteristics, altitude[0][i], azimuth[0][i], 'Hemisphere partitioning', skyviewimage_out, 0, 5, 0)

        # Save files for Tree Planter
        if parameter_dict["outputTreeplanter"]:
            logger.debug("Saving files for Tree Planter tool")
            # feedback.setProgressText("Saving files for Tree Planter tool")
            # Save DSM
            copyfile(filepath_dsm, parameter_dict["outputDir"] + '/DSM.tif')

            # Save met file
            # copyfile(parameter_dict["inputMet"], parameter_dict["outputDir"] + '/metfile.txt')

            # Save CDSM
            if usevegdem == 1:
                copyfile(filePath_cdsm, parameter_dict["outputDir"] + '/CDSM.tif')

            # Saving settings from SOLWEIG for SOLWEIG1D in TreePlanter
            settingsHeader = 'UTC, posture, onlyglobal, landcover, anisotropic, cylinder, albedo_walls, albedo_ground, emissivity_walls, emissivity_ground, absK, absL, elevation, patch_option'
            settingsFmt = '%i', '%i', '%i', '%i', '%i', '%i', '%1.2f', '%1.2f', '%1.2f', '%1.2f', '%1.2f', '%1.2f', '%1.2f', '%i'
            logger.debug(f"types: utc {type(parameter_dict['utc'])} \n"
                        f"pos {type(parameter_dict['pos'])}\n"
                        f"onlyglobal {type(parameter_dict['onlyglobal'])}\n"
                        f"landcover {type(landcover)}\n"
                        f"anisotropic sky {type(anisotropic_sky)}\n"
                        f"cyl {type(parameter_dict['cyl'])}\n"
                        f"albedo b {type(parameter_dict['albedo_b'])}\n"
                        f"albedo g {type(parameter_dict['albedo_g'])}\n"
                        f"ewall {type(parameter_dict['ewall'])}\n"
                        f"eground {type(parameter_dict['eground'])}\n"
                        f"absK {type(parameter_dict['absK'])}\n"
                        f"absL {type(parameter_dict['absL'])}\n"
                        f"alt {type(alt)}\n"
                        f"patch option {type(patch_option)}")
            settingsData = np.array([[parameter_dict["utc"], parameter_dict["pos"], parameter_dict["onlyglobal"],
                                      landcover, anisotropic_sky, parameter_dict["cyl"], parameter_dict["albedo_b"],
                                      parameter_dict["albedo_g"], parameter_dict["ewall"], parameter_dict["eground"],
                                      parameter_dict["absK"], parameter_dict["absL"], alt, patch_option]])
            # todo: typeError: Mismatch between array dtype ('<U32') and format specifier ('%i %i %i %i %i %i %1.2f %1.2f %1.2f %1.2f %1.2f %1.2f %1.2f %i')
            np.savetxt(os.path.join(parameter_dict["outputDir"], 'treeplantersettings.txt'),
                       settingsData, fmt=settingsFmt, header=settingsHeader, delimiter=' ')

        # Output I0 vs. Kglobal plot
        radG_for_plot = radG[DOY == first_unique_day[0]]
        hours_for_plot = hours[DOY == first_unique_day[0]]
        fig, ax = plt.subplots()
        ax.plot(hours_for_plot, I0_array, label='I0')
        ax.plot(hours_for_plot, radG_for_plot, label='Kglobal')
        ax.set_ylabel('Shortwave radiation [$Wm^{-2}$]')
        ax.set_xlabel('Hours')
        ax.set_title('UTC' + str(int(parameter_dict["utc"])))
        ax.legend()
        fig.savefig(parameter_dict["outputDir"] + '/metCheck.png', dpi=150)

        # Copying met file for SpatialTC
        copyfile(parameter_dict["inputMet"], parameter_dict["outputDir"] + '/metforcing.txt')

        tmrtplot = tmrtplot / Ta.__len__()  # fix average Tmrt instead of sum, 20191022
        saveraster(gdal_dsm, os.path.join(parameter_dict["outputDir"], 'Tmrt_average.tif'), tmrtplot)
        logger.debug("SOLWEIG: Model calculation finished.")

        rmtree(self.temp_dir, ignore_errors=True)
     
        return {self.OUTPUT_DIR: parameter_dict["outputDir"]}
    
    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Outdoor Thermal Comfort: SOLWEIG'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr('Outdoor Thermal Comfort: SOLWEIG v2022a')

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Processor'

    def shortHelpString(self):
        return self.tr('SOLWEIG (v2022a) is a model which can be used to estimate spatial variations of 3D radiation fluxes and '
                       'mean radiant temperature (Tmrt) in complex urban settings. The SOLWEIG model follows the same '
                       'approach commonly adopted to observe Tmrt, with shortwave and longwave radiation fluxes from  '
                       'six directions being individually calculated to derive Tmrt. The model requires a limited number '
                       'of inputs, such as direct, diffuse and global shortwave radiation, air temperature, relative '
                       'humidity, urban geometry and geographical information (latitude, longitude and elevation). '
                       'Additional vegetation and ground cover information can also be used to imporove the estimation of Tmrt.\n'
                       '\n'
                       'Tools to generate sky view factors, wall height and aspect etc. is available in the pre-processing past in UMEP\n'
                       '\n'
                       '------------\n'
                       '\n'
                       'Full manual available via the <b>Help</b>-button.')

    def helpUrl(self):
        url = "https://umep-docs.readthedocs.io/en/latest/processor/Outdoor%20Thermal%20Comfort%20SOLWEIG.html"
        return url

    # Functions tr(..) and icon(..) are not required in the standalone version
    # def tr(self, string):
    #     return QCoreApplication.translate('Processing', string)

    # def icon(self):
    #     cmd_folder = Path(os.path.split(inspect.getfile(inspect.currentframe()))[0]).parent
    #     icon = QIcon(str(cmd_folder) + "/icons/icon_solweig.png")
    #     return icon

    def createInstance(self):
        return ProcessingSOLWEIGAlgorithm()

    def set_solweig_parameter(self, parameters: Dict[str, Any]) -> Dict[str,Any]:
        """
        Evaluates the parameters with matching definition from 'parameters' to the expected format
        and checks ProcessingSolweigAlgorithm boundary conditions

        Args:
            context: context of application
            parameters: dictionary of parameters

        Returns:
            dictionary of checked parameters

        """

        parameter_dict = {}
        # InputParameters
        parameter_dict["dsmlayer"] = self._check_parameter(parameters, self.INPUT_DSM, check_dir=True)
        parameter_dict["transVeg"] = self._check_parameter(parameters, self.TRANS_VEG) / 100.
        parameter_dict["firstdayleaf"] = self._check_parameter(parameters, self.LEAF_START)
        parameter_dict["lastdayleaf"] = self._check_parameter(parameters, self.LEAF_END)
        parameter_dict["conifer_bool"] = self._check_parameter(parameters, self.CONIFER_TREES)
        parameter_dict["vegdsm"] = self._check_parameter(parameters, self.INPUT_CDSM, check_dir=True)
        parameter_dict["vegdsm2"] = self._check_parameter(parameters, self.INPUT_TDSM, check_dir=True)
        parameter_dict["lcgrid"] = self._check_parameter(parameters, self.INPUT_LC, check_dir=True)
        parameter_dict["useLcBuild"] = self._check_parameter(parameters, self.USE_LC_BUILD)
        parameter_dict["dem"] = self._check_parameter(parameters, self.INPUT_DEM, check_dir=True)
        parameter_dict["inputSVF"] = self._check_parameter(parameters, self.INPUT_SVF, check_dir=True)
        logger.debug(f"inputSVF is {parameter_dict['inputSVF']}")
        parameter_dict["whlayer"] = self._check_parameter(parameters, self.INPUT_HEIGHT, check_dir=True)
        parameter_dict["walayer"] = self._check_parameter(parameters, self.INPUT_ASPECT, check_dir=True)
        parameter_dict["trunkr"] = self._check_parameter(parameters, self.INPUT_THEIGHT)
        parameter_dict["onlyglobal"] = self._check_parameter(parameters, self.ONLYGLOBAL)
        parameter_dict["utc"] = self._check_parameter(parameters, self.UTC)
        parameter_dict["inputMet"] = self._check_parameter(parameters, self.INPUT_MET, check_dir=True)
        # usePOI = self.parameterAsBool(parameters, self.POI, context)
        parameter_dict["poilyr"] = self._check_parameter(parameters, self.POI_FILE, check_dir=True)
        parameter_dict["poi_field"] = self._check_parameter(parameters, self.POI_FIELD)
        parameter_dict["mbody"] = self._check_parameter(parameters, self.WEIGHT)
        parameter_dict["ht"] = self._check_parameter(parameters, self.HEIGHT) / 100.
        parameter_dict["clo"] = self._check_parameter(parameters, self.CLO)
        parameter_dict["age"] = self._check_parameter(parameters, self.AGE)
        parameter_dict["activity"] = self._check_parameter(parameters, self.ACTIVITY)
        parameter_dict["sex"] = self._check_parameter(parameters, self.SEX) + 1
        parameter_dict["sensorheight"] = self._check_parameter(parameters, self.SENSOR_HEIGHT)
        parameter_dict["saveBuild"] = self._check_parameter(parameters, self.SAVE_BUILD)
        parameter_dict["folderPathPerez"] = self._check_parameter(parameters, self.INPUT_ANISO, check_dir=True)

        # Other parameters #
        parameter_dict["absK"] = self._check_parameter(parameters, self.ABS_S)
        parameter_dict["absL"] = self._check_parameter(parameters, self.ABS_L)
        parameter_dict["pos"] = self._check_parameter(parameters, self.POSTURE)
        parameter_dict['cyl'] = self._check_parameter(parameters, self.CYL)

        if parameter_dict['cyl']:
            parameter_dict['cyl'] = 1
        else:
            parameter_dict['cyl'] = 0

        if parameter_dict["pos"] == 0:
            parameter_dict["Fside"] = 0.22
            parameter_dict["Fup"] = 0.06
            parameter_dict["height"] = 1.1
            parameter_dict["Fcyl"] = 0.28
        else:
            parameter_dict["Fside"] = 0.166666
            parameter_dict["Fup"] = 0.166666
            parameter_dict["height"] = 0.75
            parameter_dict["Fcyl"] = 0.2

        parameter_dict["albedo_b"] = self._check_parameter(parameters, self.ALBEDO_WALLS)
        parameter_dict["albedo_g"] = self._check_parameter(parameters, self.ALBEDO_GROUND)
        parameter_dict["ewall"] = self._check_parameter(parameters, self.EMIS_WALLS)
        parameter_dict["eground"] = self._check_parameter(parameters, self.EMIS_GROUND)
        parameter_dict["elvis"] = 0 # option removed 20200907 in processing UMEP

        # OutputParameters
        parameter_dict["outputDir"] = self._check_parameter(parameters, self.OUTPUT_DIR)
        parameter_dict["outputTmrt"] = self._check_parameter(parameters, self.OUTPUT_TMRT)
        parameter_dict["outputSh"] = self._check_parameter(parameters, self.OUTPUT_SH)
        parameter_dict["outputKup"] = self._check_parameter(parameters, self.OUTPUT_KUP)
        parameter_dict["outputKdown"] = self._check_parameter(parameters, self.OUTPUT_KDOWN)
        parameter_dict["outputLup"] = self._check_parameter(parameters, self.OUTPUT_LUP)
        parameter_dict["outputLdown"] = self._check_parameter(parameters, self.OUTPUT_LDOWN)
        parameter_dict["outputTreeplanter"] = self._check_parameter(parameters, self.OUTPUT_TREEPLANTER)
        parameter_dict["outputKdiff"] = False

        # If "Save necessary rasters for TreePlanter tool" is ticked, save Tmrt and Shadow rasters
        if parameter_dict["outputTreeplanter"]:
            parameter_dict["outputTmrt"] = True
            parameter_dict["outputKup"] = True
            parameter_dict["outputKdown"] = True
            parameter_dict["outputLup"] = True
            parameter_dict["outputLdown"] = True
            parameter_dict["outputSh"] = True
            parameter_dict["saveBuild"] = True
            parameter_dict["outputKdiff"] = True

        if parameters['OUTPUT_DIR'] == 'TEMPORARY_OUTPUT':
            output_path = os.path.join(os.getcwd(), parameter_dict["outputDir"])
            if not os.path.isdir(output_path):
                os.mkdir(output_path)
        # if OUTPUT_DIR is given as absolute path
        elif os.path.isabs(parameters['OUTPUT_DIR']):
            if not os.path.isdir(parameter_dict["outputDir"]):
                os.mkdir(output_path)
        # if OUTPUT_DIR is given as relative path
        else:
            output_path = os.path.join(os.getcwd(), parameter_dict["outputDir"])
            if not os.path.isdir(output_path):
                os.mkdir(output_path)

        return parameter_dict

    def _check_parameter(self, parameter_list, eigen_parameter, check_dir=False):
        try:
            value = parameter_list[eigen_parameter]
        except:
            raise KeyError(f"Parameter {eigen_parameter} was not defined.")
        expected_type = self.param_desc_dict[eigen_parameter]['type']

        if 'extension' in self.param_desc_dict[eigen_parameter].keys():
            ext = self.param_desc_dict[eigen_parameter]['extension']
            if ext not in str(value):
                ValueError(f"Given file has wrong extension {value} {ext}")

        logger.debug(f"{value} expected type {expected_type} Any? {expected_type is Any} matching?"
                     f"{isinstance(value, expected_type)} str? {expected_type == str}  tif? {'tif' in str(value)}")
        if expected_type is Any:
            return value
        elif isinstance(value, expected_type):
            if type(value) == str and value != "None" and check_dir:
                if not os.path.exists(str(value)):
                    raise FileNotFoundError(errno.ENOENT, os.strerror(errno.ENOENT), str(value))
            return value
        elif expected_type == str:
            return str(value)

        else:
            raise TypeError(f"Value and expected type did not match. "
                            f"Expected {expected_type}, got value of type {type(value)}")
